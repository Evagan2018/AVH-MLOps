# This YAML file is used to test a custom Docker image with the necessary tools and dependencies for an ML project
# It contains a job that runs tests on a Ubuntu machine using the custom Docker image

name: Licensed Docker Image - Test

on:
  # Trigger the workflow when a workflow run is completed
  workflow_run:
    workflows: ["Licensed Docker Image - Build and Push"]
    types:
      - completed
  # Trigger the workflow manually
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/avh-mlops

jobs:

  check-docker-image:
    runs-on: ubuntu-latest
    outputs:
      image-exists: ${{ steps.check.outputs.exists }}
      repo-slug: ${{ steps.slug.outputs.repo_slug }}
    steps:
      - name: Derive lowercase repo slug
        id: slug
        run: echo "repo_slug=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Check if Docker image exists
        id: check
        run: |
          if docker manifest inspect ghcr.io/$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')/arm-mlops-docker-licensed:latest > /dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Diagnosis
        run: |
          echo "Repository Slug: ${{ steps.slug.outputs.repo_slug }}"
          echo "Image Exists: ${{ steps.check.outputs.exists }}"

  run_test:
    needs: check-docker-image
    runs-on: ubuntu-latest

    container:
      # Use the custom Docker image with the necessary tools and dependencies
      image: ghcr.io/${{ needs.check-docker-image.outputs.repo-slug }}/arm-mlops-docker-licensed:latest
      credentials:
        # Set the Docker image credentials using the actor and a GitHub token
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - name: Checkout repository
        # Check out the repository containing the ML project
        uses: actions/checkout@v5

      # Diagnostic steps to understand the workspace and vcpkg setup starting here
      - name: Debug workspace (robust)
        run: |
          # Turn off 'exit on error' that GitHub's sh enables, so optional probes won't kill the step
          set +e

          # Safely show common env vars (use defaults to avoid 'unset' crashes)
          printf 'SHELL=%s\n' "${SHELL:-<unset>}"
          printf 'GITHUB_WORKSPACE=%s\n' "${GITHUB_WORKSPACE:-<unset>}"
          printf 'github.workspace=%s\n' "${{ github.workspace }}"
          printf 'PWD=%s\n' "$(pwd)"
          printf 'VCPKG_ROOT=%s\n' "${VCPKG_ROOT:-<unset>}"

          echo "Directory structure (3 levels):"
          if command -v tree >/dev/null 2>&1; then
            tree -L 3
          else
            echo "(tree not installed; using find)"
            # List dirs/files up to depth 3
            find . -maxdepth 3 -printf '%y %p\n' | sort
          fi

          echo "Contents of root:"
          ls -la

          echo "Looking for vcpkg manifest files at repo root:"
          ls -la vcpkg-configuration.json vcpkg-artifacts.json 2>/dev/null || echo "No vcpkg artifact manifests at root"

          for d in tools/ci docker_base docker_licensed ; do
            if [ -d "$d" ]; then
              echo "== $d =="
              ls -la "$d"
            fi
          done

      # Diagnostic steps to understand the workspace and vcpkg setup ending here

      - name: Use vcpkg to install tools
        working-directory: docker_base
        run: |
          vcpkg activate --downloads-root="${GITHUB_WORKSPACE}/.vcpkg-downloads" --json="${GITHUB_WORKSPACE}/env.json"

      - name: Inspect vcpkg env.json and locate cbuild
        shell: bash
        run: |
          set -euo pipefail
          echo "GITHUB_WORKSPACE=${GITHUB_WORKSPACE}"
          ls -l "${GITHUB_WORKSPACE}/env.json"

          echo "---- env.json (first 200 lines) ----"
          sed -n '1,200p' "${GITHUB_WORKSPACE}/env.json" || true
          echo "------------------------------------"

          echo "---- environment keys in env.json ----"
          python3 - <<'PY'
          import json, os
          p = os.environ["GITHUB_WORKSPACE"] + "/env.json"
          env = json.load(open(p)).get("environment", {})
          print("count:", len(env))
          for k in sorted(env):
              print(k)
          print("\nPATH entry present:", "PATH" in env)
          if "PATH" in env:
              print("\nPATH from env.json:\n", env["PATH"])
          # Show anything CMSIS-related
          print("\nCMSIS-related vars:")
          for k,v in env.items():
              if "CMSIS" in k.upper() or "TOOLBOX" in k.upper():
                  print(k, "=", v)
          PY
          echo "---------------------------------------"

          echo "---- search for cbuild on disk (this may take a bit) ----"
          # Try in workspace (artifacts usually unpack under the downloads root we set)
          find "${GITHUB_WORKSPACE}" -type f -name cbuild -perm -111 -printf '%p\n' 2>/dev/null | sed -n '1,20p' || true
          echo "---------------------------------------------------------"
          
      - name: Export vcpkg environment for subsequent steps (robust)
        shell: bash
        run: |
          set -euo pipefail
          P="${GITHUB_WORKSPACE}/env.json"
          GE="${GITHUB_ENV}"

          if [[ ! -f "$P" ]]; then
            echo "env.json not found at $P"; exit 1
          fi

          # 1) Read env.json
          python3 - "$P" "$GE" <<'PY'
          import json, os, sys
          p, ge = sys.argv[1], sys.argv[2]
          data = json.load(open(p))
          env = data.get("environment", {})

          # Append vcpkg-provided variables to GITHUB_ENV
          with open(ge, "a") as out:
              for k,v in env.items():
                  v = (v or "").replace("\n", " ")
                  out.write(f"{k}={v}\n")
          print("Wrote", len(env), "vars from env.json to $GITHUB_ENV")
          PY

          # 2) If PATH wasn't provided (or doesn't contain cbuild), try to discover CMSIS toolbox 'bin'
          #    and append to $GITHUB_ENV.
          #    We defaulted downloads-root to ${GITHUB_WORKSPACE}/.vcpkg-downloads during activation,
          #    so artifacts should be under there somewhere.
          echo "::group::Attempt PATH repair for cbuild"
          if ! command -v cbuild >/dev/null 2>&1; then
            CBUILD_BIN="$(find "${GITHUB_WORKSPACE}" -type f -name cbuild -perm -111 2>/dev/null | head -n1 || true)"
            if [[ -n "${CBUILD_BIN}" ]]; then
              CBUILD_DIR="$(dirname "$CBUILD_BIN")"
              echo "Found cbuild at: $CBUILD_BIN"
              echo "PATH=$CBUILD_DIR:\$PATH" >> "$GE"
              echo "Appended $CBUILD_DIR to PATH in \$GITHUB_ENV"
            else
              echo "Could not locate cbuild on disk; PATH will remain unchanged"
            fi
          else
            echo "cbuild already on PATH in this step (good)."
          fi
          echo "::endgroup::"
          
      - name: Test cbuild version
        # Test if the armclang command is working in the Docker container
        run: |
          cbuild --version
 
